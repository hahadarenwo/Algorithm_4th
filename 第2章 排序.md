# 排序

## 目录

[简单选择排序](#简单选择排序)
[插入排序](#插入排序)
[希尔排序](#希尔排序)
[部分课后题答案](#部分课后题答案)

## 简单选择排序

### 概述

首先找到数组中最小的那个元素，其次将它和数组的第一个元素交换位置（如果第一个元素就是最小元素那么它就和自己交换）。再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。这种方法叫做选择排序，因为它在不断地选择剩余元素之中的最小者。
  
对于长度为N的数组，选择排序需要大约`N^2/2`次比较和`N`次交换。

优点是简单、数据移动是最少的（始终为N次），缺点是运行时间和输入顺序无关（无法利用输入的初始状态减少比较次数）。

### 代码

```
class SelectionSort {
public:
    void sort(vector<int>& a) {
        int N = a.size();
        for (int i = 0; i < N; ++i) {
            int min = i;//最小元素的索引
            for (int j = i + 1; j < N; ++j) {
                if (a[j] < a[min]) {
                    min = j;
                }
            }
            swap(a[i], a[min]);
        }
    }
};
```

## 插入排序

### 概述

通常人们整理桥牌的方法是一张一张的来，将每一张牌插入到其他已经有序的牌中的适当位置。在计算机的实现中，为了给要插入的元素腾出空间，我们需要将其余所有元素在插入之前都向右移动一位。这种算法叫做插入排序。与选择排序一样，当前索引左边的所有元素都是有序的，但它们的最终位置还不确定，为了给更小的元素腾出空间，它们可能会被移动。但是当索引到达数组的右端时，数组排序就完成了。

插入排序所需的时间取决于输入中元素的初始顺序。例如，对一个很大且其中的元素已经有序（或接近有序）的数组进行排序将会比对随机顺序的数组或是逆序数组进行排序要快得多。

对于随机排列的长度为N且主键不重复的数组，平均情况下插入排序需要`N^2/4` 次比 较以及`N^2/4` 次交换。

插入排序对于**部分有序**的数组十分高效，也很适合**小规模数组**。

### 代码

```
class InsertionSort {
public:
    void sort(vector<int>& a) {
        int N = a.size();
        for (int i = 0; i < N; ++i) {
            for (int j = i; j > 0 && (a[j] < a[j - 1]); j--) {
                swap(a[j], a[j - 1]);
            }
        }
    }
};

```

## 希尔排序

### 概述
希尔排序是**基于插入排序**的快速的排序算法。因为插入排序只能交换相邻的元素，元素只能一点一点从一端移动到另一端，因此对于大规模乱序数组插入排序很慢。

希尔排序为了加快速度简单地改进了插入排序，**交换不相邻的元素**以对数组的**局部进行排序**，并**最终用插入排序**将局部有序的数组排序。

希尔排序的思想是使数组中任意间隔为 h 的元素都是有序的。实现希尔排序的一种方法是对于每个 h，用**插入排序**将 h 个子数组独立地排序。
![pic1.png](https://note.youdao.com/yws/res/249/WEBRESOURCE15142ee076bfdcb53cf7403e1343f29f)

希尔排序的时间复杂度达不到`N^2`级别，介于`N`和`N^2`之间。其他排序算法对于很大的N可能只会比写入排序快不到2倍，因此如果你需要解决一个排序问题而又没有系统排序函数可用，可以先用希尔排序，然后再考虑是否值得将它替换为更加复杂的排序算法。

### 代码

```
class Shell {
public:
    void sort(vector<int>& a) {
        int N = a.size();
        int h = 1;
        while (h < N/3) {
            h = 3 * h + 1;
        }
        while (h >= 1) {
            //将数组变为以h为间隔的有序,从右侧开始往最左端交换。
            for (int i = h; i < N; ++i) {
                for (int j = i; j >= h && a[j] < a[j - h]; j -= h) {
                    swap(a[j], a[j - h]);
                }
            }
            h /= 3;
        }
    }
};
```

## 部分课后题答案
2.1.2
最多可能被交换N-1次，发生在最大的元素是第一个元素，其他元素有序时。比如{5，1，2，3，4}。

平均交换2次。

2.1.6
插入排序更快。

2.1.7
选择排序更快。逆序情况下选择排序只需要N次交换，插入排序需要N^2/2次交换。

2.1.8
平方级别。插入排序只有在数组有序或者数组数字全部相同时才能有线性运行时间。

2.1.10
因为在处理局部有序数组的时候，插入排序所需时间更少。此外在最后一次排序中，希尔排序的间隔h会下降到1，此时等同于普通的选择排序。